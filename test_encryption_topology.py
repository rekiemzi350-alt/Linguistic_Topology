
import struct
import sys

# Import the logic from our previous app
from linguistic_topology_app import TopologyAnalyzer, LatinModule, MiddleFrenchModule, ProvencalModule, NavajoModule

# Add a Modern English Module for the test
class ModernEnglishModule:
    def __init__(self):
        self.name = "MODERN ENGLISH"
        self.ones = ["", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", 
                "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"]
    
    def get_length(self, n):
        # Simplified for demo speed
        if n == 0: return 4
        s = ""
        temp_n = n
        if temp_n >= 1000: return 15 # "one thousand..." approx
        if temp_n >= 100:
            s += self.ones[temp_n // 100] + "hundred"
            temp_n %= 100
        if temp_n >= 20:
            tens = ["", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"]
            s += tens[temp_n // 10]
            temp_n %= 10
        if temp_n > 0:
            s += self.ones[temp_n]
        return len(s)

# ==========================================
# 64-BIT ENCRYPTION SIMULATION (TEA Cipher)
# ==========================================
def tea_encrypt(v, k):
    """Tiny Encryption Algorithm (64-bit block cipher)."""
    y, z = v[0], v[1]
    sum_val = 0
    delta = 0x9e3779b9
    n = 32
    
    w = k[0:4]
    
    while n > 0:
        sum_val = (sum_val + delta) & 0xFFFFFFFF
        y = (y + (((z << 4) + k[0]) ^ (z + sum_val) ^ ((z >> 5) + k[1]))) & 0xFFFFFFFF
        z = (z + (((y << 4) + k[2]) ^ (y + sum_val) ^ ((y >> 5) + k[3]))) & 0xFFFFFFFF
        n -= 1
        
    return [y, z]

def encrypt_text(text, key):
    # Pad text to 8 bytes (64 bits)
    while len(text) % 8 != 0:
        text += " "
        
    encrypted_values = []
    
    # Process in 64-bit blocks
    for i in range(0, len(text), 8):
        block = text[i:i+8]
        # Unpack 8 bytes into two 32-bit integers
        v = struct.unpack(">II", block.encode('utf-8'))
        enc_v = tea_encrypt(v, key)
        
        # We treat the resulting encrypted blocks as our "Number Sequence"
        # To keep numbers manageable for the topology check (which works best on 0-500),
        # we'll take the modulo 1000 of the encrypted chunks.
        # This simulates looking at "byte values" or "page numbers" in an encrypted file.
        encrypted_values.append(enc_v[0] % 500)
        encrypted_values.append(enc_v[1] % 500)
        
    return encrypted_values

def plaintext_to_sequence(text):
    """Converts text to a sequence of ascii values for control test."""
    return [ord(c) for c in text if ord(c) < 500]

# ==========================================
# THE TEST
# ==========================================

def run_test():
    print("--- ENCRYPTION TOPOLOGY TEST ---")
    
    # 1. The Input (High-River English)
    paragraph = "the quick brown fox jumps over the lazy dog near the river"
    print(f"Plaintext: '{paragraph}'")
    
    # 2. Control Test (Is the plaintext detected as English?)
    # We convert words to numbers roughly to test the 'River' in the raw thought
    # (Here we just use ASCII values as a rough proxy for the 'sequence')
    # Better: Let's use the 'Letter Count Sequence' itself as the plaintext input
    # 3 (the) -> 5 (quick) -> 5 (brown)...
    # Actually, let's stick to the numbers generated by the ENCRYPTION.
    
    # Key for 64-bit encryption (128-bit key split into 4 integers)
    key = [0x9e3779b9, 0x9e3779b9, 0x12345678, 0x87654321]
    
    # 3. Encrypt
    enc_sequence = encrypt_text(paragraph, key)
    print(f"\nEncrypted Sequence (First 10): {enc_sequence[:10]}...")
    print(f"Total Encrypted Blocks: {len(enc_sequence)}")
    
    # 4. Run Topology Analysis
    modules = [
        ModernEnglishModule(),
        LatinModule(),
        MiddleFrenchModule(),
        NavajoModule()
    ]
    
    print("\nRunning Linguistic Topology Scan on Ciphertext...")
    print("-" * 50)
    
    for mod in modules:
        score = TopologyAnalyzer.analyze(enc_sequence, mod)
        print(f"  Testing vs {mod.name:<20} | Confidence: {score:.1f}%")
        
    print("-" * 50)
    
    # 5. Interpretation
    print("\nCONCLUSION:")
    eng_score = TopologyAnalyzer.analyze(enc_sequence, ModernEnglishModule())
    if eng_score < 10:
        print("  [SUCCESS] The encryption successfully destroyed the Linguistic Topology.")
        print("  The 'River' has been scattered into random noise.")
    else:
        print("  [WARNING] The encryption is LEAKING topological data!")
        print("  The source language is still detectable.")

if __name__ == "__main__":
    run_test()
